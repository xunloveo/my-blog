(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{225:function(t,i,v){"use strict";v.r(i);var _=v(0),r=Object(_.a)({},(function(){var t=this,i=t.$createElement,v=t._self._c||i;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"git-常用操作与指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#git-常用操作与指令"}},[t._v("#")]),t._v(" git 常用操作与指令")]),t._v(" "),v("p",[t._v("Git 本地代码第一次提交到远程的操作")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("本地 初始化 \t\ngit init")])]),t._v(" "),v("li",[v("p",[t._v("暂存\ngit add .")])]),t._v(" "),v("li",[v("p",[t._v("提交\ngit commit -m ''")])]),t._v(" "),v("li",[v("p",[t._v("添加到远程\ngit remote add origin 远程仓库地址")])]),t._v(" "),v("li",[v("p",[t._v("代码提交远程\ngit push -u origin master")])]),t._v(" "),v("li",[v("p",[t._v("远程获取代码后(会新建develop分支)： git flow init")])]),t._v(" "),v("li",[v("p",[t._v("新建分支： git flow feature start issue#1")])]),t._v(" "),v("li",[v("p",[t._v("git  add . 所有的 也可以单个添加")])]),t._v(" "),v("li",[v("p",[t._v("git commit -m 'commit'")])]),t._v(" "),v("li",[v("p",[t._v("git flow feature finish issue#1")])]),t._v(" "),v("li",[v("p",[t._v("git pull 拉取代码合并 然后在提交到远程"),v("br"),t._v("\ngit pull <远程主机名> <远程分支名>  取回远程主机某个分支的更新，再与本地的指定分支合并 例如：项目所在的远程主机是origin  远程主分支名为master 我们就可以写成 git pull origin master")])])]),t._v(" "),v("p",[t._v("git pull是git fetch后跟git merge FETCH_HEAD的缩写"),v("br"),t._v("\ngit fetch：相当于是从远程获取最新版本到本地，不会自动合并")]),t._v(" "),v("p",[t._v("$ git fetch origin master:tmp"),v("br"),t._v("\n$ git diff tmp"),v("br"),t._v("\n$ git merge tmp"),v("br"),t._v("\n查看文件修改：\ngit  diff  查看未暂存的文件"),v("br"),t._v("\ngit diff --cached 或者 git diff --staged   查看暂存的文件")]),t._v(" "),v("p",[t._v("删除本地分支：")]),t._v(" "),v("ul",[v("li",[t._v("隶属分支： git  branch -d dev1")]),t._v(" "),v("li",[t._v("不隶属分支: git branch -D dev2")])]),t._v(" "),v("p",[t._v("删除远程分支："),v("br"),t._v("\ngit branch origin --delete dev3  或者 git push origin :分支名")]),t._v(" "),v("p",[t._v("提交到远程："),v("br"),t._v("\ngit push origin develop")]),t._v(" "),v("p",[t._v("分支上获取最新代码： git rebase develop  (相当于把develop分支上的提交合并到当前分支）"),v("br"),t._v("\n因为顺序是重新整理的，所以肯定会出现冲突"),v("br"),t._v("\n解决冲突，最后 git add * ，但不许要git commit"),v("br"),t._v("\n解决后，执行 git rebase --continue"),v("br"),t._v("\n重新提交代码： git push for-*")]),t._v(" "),v("p",[t._v("master分支代码合并："),v("br"),t._v("\ngit merge develop")]),t._v(" "),v("p",[t._v("$ git merge --squash another"),v("br"),t._v('\n$ git commit -m "message here"'),v("br"),t._v("\n--squash 选项的含义是：本地文件内容与不使用该选项的合并结果相同，但是不提交、不移动HEAD，因此需要一条额外的commit命令。其效果相当于将another分支上的多个commit合并成一个，放在当前分支上，原来的commit历史则没有拿过来。")]),t._v(" "),v("p",[t._v("删除文件git 仓库："),v("br"),t._v("\ngit rm -rf .git")]),t._v(" "),v("p",[t._v("git stash （储藏）用法："),v("br"),t._v("\n经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。")]),t._v(" "),v("p",[t._v("“‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。")]),t._v(" "),v("p",[t._v("查看所有的存储"),v("br"),t._v("\ngit stash list"),v("br"),t._v("\n应用存储"),v("br"),t._v("\ngit stash apply"),v("br"),t._v("\n如果你想应用更早的储藏，你可以通过名字指定它，像这样：git stash apply stash@{2}。如果你不指明，Git 默认使用最近的储藏并尝试应用它\n你也可以运行 git stash pop 来重新应用储藏，同时立刻将其从堆栈中移走")]),t._v(" "),v("p",[t._v("参考网站： https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001376026233004c47f22a16d1f4fa289ce45f14bbc8f11000")]),t._v(" "),v("p",[t._v("查看提交的日志"),v("br"),t._v("\ngit log（查询所有的）"),v("br"),t._v("\ngit log -p  显示每次提交的内容差异"),v("br"),t._v("\ngit log -p -2  显示两次的提交"),v("br"),t._v("\ngit log --stat 查看简略的信息"),v("br"),t._v("\n--pretty  使用不同于默认格式的方式展开提交历史 有4个值 online short full fuller"),v("br"),t._v("\ngit log --pretty=online  每个提交放在一行显示")]),t._v(" "),v("p",[t._v("撤销操作"),v("br"),t._v("\n有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交："),v("br"),t._v("\ngit comimit --amend"),v("br"),t._v("\n；如"),v("br"),t._v("\ngit commit -m 'initial commit'"),v("br"),t._v("\ngit add forgotten_file"),v("br"),t._v("\ngit commit --amend"),v("br"),t._v("\n第二次的提交 将替代第一次的提交")]),t._v(" "),v("p",[t._v("打标签"),v("br"),t._v("\ngit tag -a v1.4 -m 'my version 1.4' 附注标签"),v("br"),t._v("\ngit tag v1.4 轻量标签"),v("br"),t._v("\ngit show tagname  查看标签"),v("br"),t._v("\ngit tag -a v1.4 9fecb002(提交的commit id) 如果在提交的时候 忘记打标签"),v("br"),t._v("\ngit push origin v1.4 共享标签 把标签 推送到远程"),v("br"),t._v("\ngit push origin --tags 把所有没有在远程的 推送到远程")])])}),[],!1,null,null,null);i.default=r.exports}}]);