{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{218:function(n,t,e){\"use strict\";e.r(t);var a=e(0),r=Object(a.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"自定义封装方法\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自定义封装方法\"}},[n._v(\"#\")]),n._v(\" 自定义封装方法\")]),n._v(\" \"),e(\"h2\",{attrs:{id:\"洗牌函数\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#洗牌函数\"}},[n._v(\"#\")]),n._v(\" 洗牌函数\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"随机获取给定区间的值\\nfunction getRandomInt(min, max) {\\n    return Math.floor(Math.random() * (max - min + 1) + min)\\n}\\n\\n洗牌函数 随机改变数组\\nfunction shuffle(arr) {\\n    let _arr = arr.slice()\\n    for (let i =0; i < arr.length; i++) {\\n        let j = getRandomInt(0, i)\\n        let t = _arr[i]\\n        _arr[i] = _arr[j]\\n        _arr[j] = t\\n    }\\n    return _arr\\n}\\n\\n\")])])]),e(\"h2\",{attrs:{id:\"js给元素设置兼容前缀\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js给元素设置兼容前缀\"}},[n._v(\"#\")]),n._v(\" js给元素设置兼容前缀\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"let elementStyle = document.createElement('div').style\\n\\nlet vendor = (() => {\\n  let transformNames = {\\n    webkit: 'webkitTransform',\\n    Moz: 'MozTransform',\\n    O: 'OTransform',\\n    ms: 'msTransform',\\n    standard: 'transform'\\n  }\\n\\n  for (let key in transformNames) {\\n    if (elementStyle[transformNames[key]] !== undefined) {\\n      return key\\n    }\\n  }\\n\\n  return false\\n})()\\n\\nexport function prefixStyle(style) {\\n  if (vendor === false) {\\n    return false\\n  }\\n\\n  if (vendor === 'standard') {\\n    return style\\n  }\\n\\n  return vendor + style.charAt(0).toUpperCase() + style.substr(1)\\n}\\n\")])])]),e(\"h2\",{attrs:{id:\"css-一些操作\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#css-一些操作\"}},[n._v(\"#\")]),n._v(\" css 一些操作\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"// 判断是否有这个类名\\nexport function hasClass(el, className) {\\n      let reg = new RegExp('(^|\\\\\\\\s)' + className + '(\\\\\\\\s|$)')\\n      return reg.test(el.className)\\n    }\\n \\n// 添加类名  \\nexport function addClass(el, className) {\\n  if (hasClass(el, className)) {\\n    return\\n  }\\n\\n  let newClass = el.className.split(' ')\\n  newClass.push(className)\\n  el.className = newClass.join(' ')\\n}\\n\\n// 设置或者获取data-\\nexport function getData(el, name, val) {\\n  const prefix = 'data-'\\n  if (val) {\\n    return el.setAttribute(prefix + name, val)\\n  }\\n  return el.getAttribute(prefix + name)\\n}\\n\")])])]),e(\"h2\",{attrs:{id:\"list转为tree\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#list转为tree\"}},[n._v(\"#\")]),n._v(\" list转为tree\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"/**\\n * 以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：\\n\\n// 原始 list 如下\\nlet list =[\\n    {id:1,name:'部门A',parentId:0},\\n    {id:2,name:'部门B',parentId:0},\\n    {id:3,name:'部门C',parentId:1},\\n    {id:4,name:'部门D',parentId:1},\\n    {id:5,name:'部门E',parentId:2},\\n    {id:6,name:'部门F',parentId:3},\\n    {id:7,name:'部门G',parentId:2},\\n    {id:8,name:'部门H',parentId:4}\\n];\\nconst result = convert(list, ...);\\n\\n// 转换后的结果如下\\nlet result = [\\n    {\\n      id: 1,\\n      name: '部门A',\\n      parentId: 0,\\n      children: [\\n        {\\n          id: 3,\\n          name: '部门C',\\n          parentId: 1,\\n          children: [\\n            {\\n              id: 6,\\n              name: '部门F',\\n              parentId: 3\\n            }, {\\n              id: 16,\\n              name: '部门L',\\n              parentId: 3\\n            }\\n          ]\\n        },\\n        {\\n          id: 4,\\n          name: '部门D',\\n          parentId: 1,\\n          children: [\\n            {\\n              id: 8,\\n              name: '部门H',\\n              parentId: 4\\n            }\\n          ]\\n        }\\n      ]\\n    },\\n  ···\\n];\\n */\\n\\nfunction convert(list) {\\n\\tconst res = []\\n\\tconst map = list.reduce((res, v) => (res[v.id] = v, res), {})\\n\\tfor (const item of list) {\\n\\t\\tif (item.parentId === 0) {\\n\\t\\t\\tres.push(item)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif (item.parentId in map) {\\n\\t\\t\\tconst parent = map[item.parentId]\\n\\t\\t\\tparent.children = parent.children || []\\n\\t\\t\\tparent.children.push(item)\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\nlet list = [\\n    {id:1,name:'部门A',parentId:0},\\n    {id:2,name:'部门B',parentId:0},\\n    {id:3,name:'部门C',parentId:1},\\n    {id:4,name:'部门D',parentId:1},\\n    {id:5,name:'部门E',parentId:2},\\n    {id:6,name:'部门F',parentId:3},\\n    {id:7,name:'部门G',parentId:2},\\n    {id:8,name:'部门H',parentId:4}\\n]\\n\\nconsole.log(convert(list))\\n\")])])]),e(\"h2\",{attrs:{id:\"函数柯里化\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#函数柯里化\"}},[n._v(\"#\")]),n._v(\" 函数柯里化\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v('/**\\n * 函数柯里化实现\\n * \\n */\\n\\nfunction currying(fn, length) {\\n\\tlength = length || fn.length // 第一次调用函数fn参数的长度， 后续调用获取fn剩余参数的长度\\n\\treturn function (...args) {\\n\\t\\tconsole.log(args.length, length)\\n\\t\\treturn args.length >= length \\n\\t\\t\\t? fn.apply(this, args)\\n\\t\\t\\t: currying(fn.bind(this, ...args), length - args.length)\\n\\t}\\n}\\n\\n// es6 简化版\\nconst simpleCurrying = fn =>\\n\\tjudge = (...args) => \\n\\t\\targs.length >= fn.length\\n\\t\\t\\t? fn(...args)\\n\\t\\t\\t: (...arg) => judge(...args, ...arg)\\n\\n// test \\nconst fn = currying(function(a, b, c) {\\n\\tconsole.log([a, b, c])\\n})\\n\\n// fn(\"a\", \"b\", \"c\")\\n// fn(\"a\", \"b\")(\"c\")\\n// fn(\"a\")(\"b\")(\"c\")\\n\\nconst f1 = simpleCurrying((a, b, c) =>\\n\\tconsole.log([a, b, c])\\n)\\nf1(\"a\", \"b\", \"c\")\\nf1(\"a\")(\"b\", \"c\")\\nf1(\"a\", \"c\")(\"b\")\\nf1(\"a\")(\"b\")(\"c\")\\n')])])]),e(\"h2\",{attrs:{id:\"自定义new\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#自定义new\"}},[n._v(\"#\")]),n._v(\" 自定义new\")]),n._v(\" \"),e(\"div\",{staticClass:\"language- extra-class\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[n._v(\"/**\\n * 实现new的思路：\\n * \\t1. 首先创建一个空的对象，空对象的_proto_属性指向构造函数的原型对象\\n * \\t2. 把上面的空对象赋值构造函数内部的this,用构造函数内部的方法修改空对象\\n * \\t3. 如果构造函数返回一个非基本类型的值，则返回这个值， 否则返回上面创建的对象\\n*/\\nfunction _new (fn, ...arg) {\\n\\tconst obj = Object.create(fn.prototype)\\n\\tconst ret = fn.apply(obj, arg)\\n\\treturn ret instanceof Object ? ret : obj\\n}\\n\\n// test\\nlet Dog = function(name) {\\n\\tthis.name = name\\n}\\nDog.prototype.bark = function() {\\n\\tconsole.log('bark')\\n}\\nDog.prototype.sayName = function () {\\n\\tconsole.log(`My name is ${this.name}`)\\n}\\n\\nlet dog = _new(Dog, 'simao')\\ndog.bark()\\ndog.sayName()\\nconsole.log(dog instanceof Dog) // true\\n\")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}